<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Gerenciador de Estacionamento 3D</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; display:block; touch-action: none; }
    #adminPanel { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); color: white; padding: 10px; border-radius: 8px; font-family: Arial; line-height: 1.4; z-index: 30;}
    #loginPanel { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.6); color: white; padding: 10px; border-radius: 8px; font-family: Arial; z-index: 30;}
    #vagaPanel { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 8px; font-family: Arial; display: none; pointer-events: auto; z-index: 30; }
    #vagaPanel button { margin: 3px; padding: 6px 10px; }
    .hint { font-size: 12px; opacity: 0.85; }

    /* Controles mobile (mantidos) */
    #mobileControls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 20px;
      z-index: 10;
    }
    #mobileControls .pad {
      display: grid;
      grid-template-columns: 70px 70px 70px;
      grid-template-rows: 70px 70px 70px;
      gap: 12px;
      justify-content: center;
      align-items: center;
    }
    #mobileControls .zoom {
      display: grid;
      grid-auto-rows: 70px;
      gap: 12px;
      margin-left: 12px;
    }
    #mobileControls button {
      border: none;
      border-radius: 20px;
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 28px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.25);
    }
    #mobileControls button:active { transform: scale(0.95); }

    @media (max-width: 1024px) { 
      #mobileControls { display: flex }
    }

    /* Lista lateral de vagas */
    #vagaList {
      position: absolute;
      top: 80px;
      right: 10px;
      width: 220px;
      max-height: 70%;
      overflow-y: auto;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-family: Arial;
      font-size: 14px;
      z-index: 40;
    }
    #vagaList h4 {
      margin: 0 0 8px;
      font-size: 16px;
      text-align: center;
    }
    .vaga-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      padding: 4px 6px;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    .vaga-item button {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="adminPanel">
  <div>Vagas livres: <span id="livres">0</span> | Ocupadas: <span id="ocupadas">0</span></div>
  <div class="hint">Admin: clique com <b>botão direito</b> em qualquer ponto para criar uma vaga</div>
</div>

<div id="loginPanel">
  Perfil:
  <select id="roleSelect">
    <option value="viewer">Usuário</option>
    <option value="operator">Operador</option>
    <option value="admin">Administrador</option>
  </select><br/>
  Senha: <input type="password" id="userPass"/>
  <button onclick="login()">Entrar</button>
</div>

<div id="vagaPanel">
  <h4>Gerenciar Vaga</h4>
  <button onclick="ocuparVaga()">Ocupar</button>
  <button onclick="liberarVaga()">Desocupar</button>
  <button onclick="rotacionarVaga(-10)">⟲ Rotacionar</button>
  <button onclick="rotacionarVaga(10)">Rotacionar ⟳</button>
  <button onclick="ativarMover()">Mover</button>
  <button onclick="deletarVaga()">Deletar</button>
</div>

<!-- Lista lateral de vagas -->
<div id="vagaList">
  <h4>Lista de Vagas</h4>
  <div id="vagaItems"></div>
</div>

<!-- Controles Mobile (opcionais) -->
<div id="mobileControls">
  <div class="pad">
    <div></div>
    <button id="btnUp">▲</button>
    <div></div>
    <button id="btnLeft">◀</button>
    <button id="btnDown">▼</button>
    <button id="btnRight">▶</button>
    <div></div>
    <div></div>
    <div></div>
  </div>
  <div class="zoom">
    <button id="btnZoomIn">＋</button>
    <button id="btnZoomOut">－</button>
  </div>
</div>

<script>
  // Mantive a sua configuração original do Firebase (copiada do seu exemplo)
  const firebaseConfig = {
    apiKey: "AIzaSyAE8AgqS_rpQygvmO6ugTX5yQSjQDwJ0vk",
    authDomain: "smamus3d.firebaseapp.com",
    databaseURL: "https://smamus3d-default-rtdb.firebaseio.com",
    projectId: "smamus3d",
    storageBucket: "smamus3d.firebasestorage.app",
    messagingSenderId: "951385126549",
    appId: "1:951385126549:web:c80ed059acdf45bdcc8d9c",
    measurementId: "G-H52V7SLBGE"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);
  let scene, camera;
  let vagas = [];
  let vagaSelecionada = null;
  let moverAtivo = false;
  let role = "viewer";
  const PASSWORDS = { operator: "op123", admin: "admin123" };
  const PARKING_MODEL_FILE = "modelo.glb"; 
  const CAR_BASE_URL = "https://linckrafael.github.io/cars3D/";
  const CAR_MODELS = ["car1.glb","car5.glb","car7.glb","car9.glb","car12.glb","car13.glb","car14.glb"];
  const VAGA_LARGURA = 4.0;
  const VAGA_COMPRIMENTO = 8.0;
  const VAGA_ALTURA = 2.0;
  const MARGEM_ESCALA = 0.95;

  // Contador sequencial (será atualizado a partir do Firebase ao carregar)
  let nextVagaNumber = 1;

  function login(){
    const selected = document.getElementById("roleSelect").value;
    const pass = document.getElementById("userPass").value;
    if(selected === "viewer"){
      role = "viewer";
      alert("Modo Visualizador");
    } else if(pass === PASSWORDS[selected]){
      role = selected;
      alert("Modo " + (role === "admin" ? "Administrador" : "Operador") + " Ativado");
    } else {
      alert("Senha incorreta");
      return;
    }
    atualizarInterface();
    atualizarListaVagas();
  }

  function atualizarInterface(){
    document.querySelectorAll("#vagaPanel button").forEach(btn => btn.style.display = "none");
    if(role === "operator"){
      document.querySelector("button[onclick='ocuparVaga()']").style.display = "inline-block";
      document.querySelector("button[onclick='liberarVaga()']").style.display = "inline-block";
    }
    if(role === "admin"){
      document.querySelectorAll("#vagaPanel button").forEach(btn => btn.style.display = "inline-block");
    }
  }

  function atualizarPainel(){
    const livres = vagas.filter(v => !v.ocupada).length;
    const ocupadas = vagas.length - livres;
    document.getElementById("livres").innerText = livres;
    document.getElementById("ocupadas").innerText = ocupadas;
  }

  scene = new BABYLON.Scene(engine);

  // =====================
  // CÂMERAS: Desktop x Mobile
  // =====================
  const isMobile = () => ("ontouchstart" in window) || navigator.maxTouchPoints > 0 || window.innerWidth <= 1024;

  function createDesktopCamera(){
    const cam = new BABYLON.UniversalCamera("desktopCam", new BABYLON.Vector3(68, 80, -15), scene);
    cam.rotation.x = Math.PI / 5;
    cam.rotation.y = 10.5;
    cam.attachControl(canvas, true);
    cam.keysUp.push(87); cam.keysDown.push(83);
    cam.keysLeft.push(65); cam.keysRight.push(68);
    cam.speed = 15;
    cam.angularSensibility = 450;
    cam.inertia = 0.1;
    cam.inputs.addMouseWheel();
    cam.wheelPrecision = 50;
    const MIN_Y = 1, MAX_Y = 100;
    scene.registerBeforeRender(()=>{
      if(cam.position.y<MIN_Y) cam.position.y=MIN_Y;
      if(cam.position.y>MAX_Y) cam.position.y=MAX_Y;
    });
    return cam;
  }

  function createMobileCamera(){
    // Queremos que a ArcRotateCamera inicie exatamente na mesma posição e orientação da câmera desktop.
    const desktopPos = new BABYLON.Vector3(68, 80, -15);
    const desktopRotX = Math.PI / 5; // mesma rotação X usada no desktop
    const desktopRotY = 10;         // mesma rotação Y usada no desktop

    // Criamos uma câmera temporária (não renderizada) para obter o vetor 'forward' a partir das rotações.
    const tmp = new BABYLON.UniversalCamera("tmpCam", desktopPos.clone(), scene);
    tmp.rotation.x = desktopRotX;
    tmp.rotation.y = desktopRotY;
    // vetor de direção para frente (normalizado)
    const forward = tmp.getDirection(new BABYLON.Vector3(0,0,1));

    // Distância na qual consideramos o ponto alvo na frente da câmera desktop.
    const targetDist = 100;
    const target = desktopPos.add(forward.scale(targetDist));

    // Calcula parâmetros alpha/beta/radius para a ArcRotate a partir da posição e do alvo.
    const radius = BABYLON.Vector3.Distance(desktopPos, target);
    const alpha = Math.atan2(desktopPos.z - target.z, desktopPos.x - target.x);
    const beta  = Math.acos((desktopPos.y - target.y) / radius);

    // limpamos a câmera temporária
    tmp.dispose();

    const cam = new BABYLON.ArcRotateCamera("mobileCam", alpha, beta, radius, target, scene);
    cam.attachControl(canvas, true);

    // Gestos
    cam.useNaturalPinchZoom = true;
    cam.pinchDeltaPercentage = 0.01;
    cam.panningSensibility = 50;
    cam.angularSensibilityTouch = 2000;

    // Limites para não atravessar/virar demais
    cam.lowerRadiusLimit = 20;
    cam.upperRadiusLimit = 400;
    cam.lowerBetaLimit   = 0.15;
    cam.upperBetaLimit   = Math.PI/2.05;

    // Pequeno amortecimento
    cam.inertia = 0.85;
    cam.zoomToMouseLocation = false; // no mobile, segue o centro

    return cam;
  }
  camera = isMobile() ? createMobileCamera() : createDesktopCamera();

  // Utilitários de movimento/zoom (funcionam para ambas as câmeras)
  const STEP = 5;
  const ZOOM_STEP = 8;
  function isArc() { return camera && camera.getClassName && camera.getClassName() === "ArcRotateCamera"; }

  function moveRelative(forward, right){
      const f = camera.getDirection(new BABYLON.Vector3(0,0,1)); f.y=0; f.normalize();
      const r = camera.getDirection(new BABYLON.Vector3(1,0,0)); r.y=0; r.normalize();
      const delta = f.scale(forward*STEP).add(r.scale(right*STEP));
      if(isArc()){
        camera.target.addInPlace(delta);
      } else {
        camera.position.addInPlace(delta);
      }
  }
  function zoomRelative(sign){
      if(isArc()){
        const next = camera.radius - sign*ZOOM_STEP;
        camera.radius = BABYLON.Scalar.Clamp(next, camera.lowerRadiusLimit||5, camera.upperRadiusLimit||300);
      } else {
        const f = camera.getDirection(new BABYLON.Vector3(0,0,1));
        camera.position.addInPlace(f.scale(sign*ZOOM_STEP));
      }
  }

  function attachHold(btn, action){
      if(!btn) return;
      let interval=null;
      const start=(e)=>{ e.preventDefault(); action(); interval=setInterval(action,100); };
      const end=()=>{ if(interval){ clearInterval(interval); interval=null; } };
      btn.addEventListener('touchstart',start,{passive:false});
      btn.addEventListener('mousedown',start);
      window.addEventListener('touchend',end);
      window.addEventListener('mouseup',end);
      window.addEventListener('touchcancel',end);
  }
  attachHold(document.getElementById('btnUp'), ()=>moveRelative(1,0));
  attachHold(document.getElementById('btnDown'), ()=>moveRelative(-1,0));
  attachHold(document.getElementById('btnLeft'), ()=>moveRelative(0,-1));
  attachHold(document.getElementById('btnRight'), ()=>moveRelative(0,1));
  attachHold(document.getElementById('btnZoomIn'), ()=>zoomRelative(1));
  attachHold(document.getElementById('btnZoomOut'), ()=>zoomRelative(-1));

  // Luz, chão e skybox
  new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
  const ground = BABYLON.MeshBuilder.CreateGround("ground",{width:1000,height:1000},scene);
  ground.position.y=-0.05;
  ground.isPickable=true;
  const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
  groundMat.diffuseColor = new BABYLON.Color3(0.4,0.4,0.4);
  ground.material=groundMat;

  const skybox=BABYLON.MeshBuilder.CreateBox("skyBox",{size:1000},scene);
  skybox.isPickable=false;
  const skyboxMat=new BABYLON.StandardMaterial("skyBoxMat",scene);
  skyboxMat.backFaceCulling=false;
  skyboxMat.diffuseColor=new BABYLON.Color3(0,0,0);
  skyboxMat.specularColor=new BABYLON.Color3(0,0,0);
  skyboxMat.reflectionTexture=new BABYLON.CubeTexture("https://playground.babylonjs.com/textures/skybox",scene);
  skyboxMat.reflectionTexture.coordinatesMode=BABYLON.Texture.SKYBOX_MODE;
  skybox.material=skyboxMat;

  BABYLON.SceneLoader.Append("https://linckrafael.github.io/Smamus3Dv7/", PARKING_MODEL_FILE, scene);

  // --- Funções utilitárias (vagas, carros, firebase) ---
  function getSizeOf(node){ const bv=node.getHierarchyBoundingVectors(true); return { size: bv.max.subtract(bv.min), bv }; }
  function criarVagaContorno(pos){ 
      const plane = BABYLON.MeshBuilder.CreatePlane("vagaPlane",{width:VAGA_LARGURA,height:VAGA_COMPRIMENTO},scene); 
      plane.rotation.x=Math.PI/2; plane.position=pos.clone().add(new BABYLON.Vector3(0,0.01,0)); 
      const mat=new BABYLON.StandardMaterial("vagaMat",scene); mat.diffuseColor=new BABYLON.Color3(0,1,0); mat.alpha=0.3; plane.material=mat; plane.isPickable=true; 
      return plane; 
  }
  function selecionarVaga(vaga){ vagaSelecionada=vaga; document.getElementById("vagaPanel").style.display="block"; atualizarInterface(); atualizarPainel(); }
  function encontrarVagaPorMesh(mesh){ return vagas.find(v=>v.mesh===mesh); }
  function normalizarOrientacao(carroRoot){ 
      let {size}=getSizeOf(carroRoot); 
      const minAxis=(size.x<=size.y && size.x<=size.z)?'x':(size.y<=size.x && size.y<=size.z?'y':'z'); 
      if(minAxis==='z'){ carroRoot.rotate(BABYLON.Axis.X,-Math.PI/2); } 
      else if(minAxis==='x'){ carroRoot.rotate(BABYLON.Axis.Z,Math.PI/2); } 
      ({size}=getSizeOf(carroRoot)); 
      if(size.x>size.z){ carroRoot.rotate(BABYLON.Axis.Y,-Math.PI/2); } 
  }
  function posicionarSobreVaga(carroRoot,vagaMesh){ 
      const {bv}=getSizeOf(carroRoot); 
      const minY=bv.min.y; 
      carroRoot.position.x=vagaMesh.position.x; 
      carroRoot.position.z=vagaMesh.position.z; 
      carroRoot.position.y=vagaMesh.position.y-minY+0.01; 
  }
  function escalarParaVaga(carroRoot){ 
      const oldRotY=carroRoot.rotation.y; carroRoot.rotation.y=0; 
      const {size}=getSizeOf(carroRoot); 
      const sx=VAGA_LARGURA/size.x; 
      const sy=VAGA_ALTURA/size.y; 
      const sz=VAGA_COMPRIMENTO/size.z; 
      const s=Math.min(sx,sy,sz)*MARGEM_ESCALA; 
      carroRoot.scaling.set(s,s,s); 
      carroRoot.rotation.y=oldRotY; 
  }

  async function carregarCarroNormalizado(vaga, modelFile){ 
      const file = modelFile || CAR_MODELS[Math.floor(Math.random()*CAR_MODELS.length)]; 
      const container = await BABYLON.SceneLoader.LoadAssetContainerAsync(CAR_BASE_URL, file, scene); 
      const carroRoot = new BABYLON.TransformNode("carroRoot",scene); 
      container.meshes.forEach(m=>{if(m.parent==null)m.parent=carroRoot;}); 
      container.addAllToScene(); 
      carroRoot.rotationQuaternion=null; 
      normalizarOrientacao(carroRoot); 
      escalarParaVaga(carroRoot); 
      carroRoot.rotation.y=vaga.mesh.rotation.y; 
      posicionarSobreVaga(carroRoot,vaga.mesh); 
      return carroRoot; 
  }

  // adiciona o número visual sobre a vaga (usa BABYLON.GUI)
  function adicionarNumeroNaVaga(vagaMesh, numero){
    // evita duplicar se já tiver
    if(!vagaMesh || vagaMesh._labelPlane) return;
    const plane = BABYLON.MeshBuilder.CreatePlane("vagaLabelPlane",{size: 2}, scene);
    // posiciona um pouco acima do chão na mesma coordenada X/Z da vaga
    plane.position = vagaMesh.position.clone().add(new BABYLON.Vector3(1.3,0.2,3));
    plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL; // sempre encara a câmera
    plane.isPickable = false;
    plane._parentVagaMesh = vagaMesh; // referência
    // cria textura GUI para o plano
    const adt = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(plane);
    const tb = new BABYLON.GUI.TextBlock();
    tb.text = numero;
    tb.color = "white";
    tb.fontSize = 500;
    tb.outlineWidth = 16;
    tb.outlineColor = "black";
    tb.fontWeight = "bold";
    adt.addControl(tb);
    // guarda referências para controlar depois (ex: mover junto, atualizar texto, remover)
    vagaMesh._labelPlane = plane;
    vagaMesh._labelADT = adt;
    vagaMesh._labelTextBlock = tb;
  }

  // atualiza/habilita texto se já existir
function atualizarNumeroVaga(vaga){
    if(!vaga) return;
    if(vaga.mesh._labelTextBlock){
        // Só o número, sem o "VAGA "
        vaga.mesh._labelTextBlock.text = vaga.numero.replace("VAGA ","");
    } else if(vaga.numero){
        adicionarNumeroNaVaga(vaga.mesh, vaga.numero.replace("VAGA ",""));
    }
}


  function atualizarFirebase(vaga, id){
      db.ref('vagas/'+id).set({
          x: vaga.mesh.position.x,
          y: vaga.mesh.position.y,
          z: vaga.mesh.position.z,
          rotY: vaga.mesh.rotation.y,
          ocupada: vaga.ocupada,
          carModel: vaga.carModel || null,
          numero: vaga.numero || null
      });
  }

  async function ocuparVagaFirebase(vaga){
      if(!vaga.ocupada) return;
      if(vaga.carro) return; 
      try{
          if(!vaga.carModel){
              vaga.carModel = CAR_MODELS[Math.floor(Math.random()*CAR_MODELS.length)];
              db.ref('vagas/'+vaga.id+'/carModel').set(vaga.carModel);
          }
          const carro = await carregarCarroNormalizado(vaga, vaga.carModel);
          vaga.carro = carro;
      }catch(e){ console.error(e); }
  }

  async function ocuparVaga(){
      if(role==="viewer"||!vagaSelecionada||vagaSelecionada.ocupada)return;
      vagaSelecionada.ocupada=true;
      if(!vagaSelecionada.carModel){
        vagaSelecionada.carModel = CAR_MODELS[Math.floor(Math.random()*CAR_MODELS.length)];
      }
      if(vagaSelecionada.mesh.material)vagaSelecionada.mesh.material.diffuseColor=new BABYLON.Color3(1,0,0);
      if(vagaSelecionada.carro){vagaSelecionada.carro.dispose(); vagaSelecionada.carro=null;}
      try{
          const carro=await carregarCarroNormalizado(vagaSelecionada, vagaSelecionada.carModel);
          vagaSelecionada.carro=carro;
          // atualiza firebase (inclui numero)
          if(vagaSelecionada.id) atualizarFirebase(vagaSelecionada, vagaSelecionada.id);
      }catch(e){
          console.error("Erro ao carregar carro:",e);
          vagaSelecionada.ocupada=false;
          vagaSelecionada.carModel=null;
          if(vagaSelecionada.mesh.material)vagaSelecionada.mesh.material.diffuseColor=new BABYLON.Color3(0,1,0);
      }
      atualizarPainel();
      atualizarListaVagas();
  }

  function liberarVaga(){
      if(role==="viewer"||!vagaSelecionada)return;
      vagaSelecionada.ocupada=false;
      vagaSelecionada.carModel=null;
      if(vagaSelecionada.mesh.material)vagaSelecionada.mesh.material.diffuseColor=new BABYLON.Color3(0,1,0);
      if(vagaSelecionada.carro){vagaSelecionada.carro.dispose(); vagaSelecionada.carro=null;}
      if(vagaSelecionada.id) atualizarFirebase(vagaSelecionada, vagaSelecionada.id);
      atualizarPainel();
      atualizarListaVagas();
  }

  function rotacionarVaga(angulo){
      if(role!=="admin"||!vagaSelecionada)return;
      const rad=BABYLON.Tools.ToRadians(angulo);
      vagaSelecionada.mesh.rotation.y+=rad;
      if(vagaSelecionada.carro){
          vagaSelecionada.carro.rotation.y+=rad;
          posicionarSobreVaga(vagaSelecionada.carro,vagaSelecionada.mesh);
      }
      if(vagaSelecionada.id) atualizarFirebase(vagaSelecionada, vagaSelecionada.id);
  }

  function ativarMover(){ if(role==="admin"&&vagaSelecionada)moverAtivo=true; }

  function deletarVaga(){
      if(role!=="admin"||!vagaSelecionada)return;
      if(vagaSelecionada.carro){vagaSelecionada.carro.dispose(); vagaSelecionada.carro=null;}
      // remove label se existir
      if(vagaSelecionada.mesh._labelPlane){ vagaSelecionada.mesh._labelPlane.dispose(); vagaSelecionada.mesh._labelPlane = null; }
      vagaSelecionada.mesh.dispose();
      if(vagaSelecionada.id) db.ref('vagas/'+vagaSelecionada.id).remove();
      vagas=vagas.filter(v=>v!==vagaSelecionada);
      vagaSelecionada=null;
      document.getElementById("vagaPanel").style.display="none";
      atualizarPainel();
      atualizarListaVagas();
  }

  // extrai número inteiro do texto "VAGA 12" etc
  function parseNumero(str){ if(!str) return null; const m = (""+str).match(/(\d+)/); return m? parseInt(m[1]) : null; }

  // Lista lateral de vagas
  function atualizarListaVagas(){
    const container = document.getElementById("vagaItems");
    container.innerHTML = "";
    // Ordena por número (se existir)
    const ordenadas = [...vagas].sort((a,b)=>{
      const na = parseNumero(a.numero)||0; const nb = parseNumero(b.numero)||0; return na-nb;
    });
    ordenadas.forEach(vaga=>{
      const item = document.createElement("div");
      item.className = "vaga-item";
      const label = document.createElement("span");
      label.textContent = `${vaga.numero || '-'} - ${vaga.ocupada ? 'Ocupada' : 'Livre'}`;
      label.style.cursor = 'pointer';
      label.onclick = ()=>{ selecionarVaga(vaga); };
      item.appendChild(label);
      if(role !== 'viewer'){
        const btn = document.createElement("button");
        btn.textContent = vaga.ocupada ? "Liberar" : "Ocupar";
        btn.onclick = ()=> toggleVagaStatus(vaga.id);
        item.appendChild(btn);
      }
      container.appendChild(item);
    });
    atualizarPainel();
  }

  async function toggleVagaStatus(id){
    const vaga = vagas.find(v => v.id === id);
    if (!vaga) return;
    vagaSelecionada = vaga;
    if (vaga.ocupada) liberarVaga();
    else await ocuparVaga();
    atualizarListaVagas();
  }

  // ==== Firebase sync das vagas ====
  db.ref('vagas').on('value', snapshot => {
      const data = snapshot.val();
      if(!data){
        // limpa se não tiver vagas
        vagas.forEach(v=>{ if(v.mesh) { if(v.mesh._labelPlane) v.mesh._labelPlane.dispose(); v.mesh.dispose(); }});
        vagas = [];
        nextVagaNumber = 1;
        atualizarPainel();
        atualizarListaVagas();
        return;
      }

      // calcula o maior número existente para continuar a numeração sequencial
      let maxNum = 0;
      Object.keys(data).forEach(id=>{ const n = parseNumero(data[id].numero); if(n && n>maxNum) maxNum=n; });
      nextVagaNumber = maxNum + 1;

      Object.keys(data).forEach(id => {
          const vData = data[id];
          let vaga = vagas.find(v=>v.id===id);
          if(!vaga){
              const novaMesh = criarVagaContorno(new BABYLON.Vector3(vData.x,vData.y,vData.z));
              novaMesh.rotation.y = vData.rotY || 0;
              if(vData.ocupada && novaMesh.material) novaMesh.material.diffuseColor = new BABYLON.Color3(1,0,0);
              else if(novaMesh.material) novaMesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
              const numero = vData.numero || `VAGA ${nextVagaNumber++}`;
              vaga = { mesh: novaMesh, ocupada: vData.ocupada, carro: null, id, carModel: vData.carModel || null, numero };
              vagas.push(vaga);
              // garante que o numero exista no DB
              if(!vData.numero){ db.ref('vagas/'+id+'/numero').set(numero); }
              // adiciona label 3D
              atualizarNumeroVaga(vaga);
              if(vaga.ocupada) ocuparVagaFirebase(vaga);
          } else {
              // atualiza posição/estado
              vaga.mesh.position.x = vData.x;
              vaga.mesh.position.y = vData.y;
              vaga.mesh.position.z = vData.z;
              vaga.mesh.rotation.y = vData.rotY || 0;
              vaga.ocupada = vData.ocupada;
              vaga.carModel = vData.carModel || null;
              vaga.numero = vData.numero || vaga.numero || null;
              if(vaga.ocupada && vaga.mesh.material) vaga.mesh.material.diffuseColor = new BABYLON.Color3(1,0,0);
              else if(vaga.mesh.material) vaga.mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
              if(vaga.ocupada && !vaga.carro) ocuparVagaFirebase(vaga);
              if(!vaga.ocupada && vaga.carro){ vaga.carro.dispose(); vaga.carro=null; }
              // atualiza label
              atualizarNumeroVaga(vaga);
              if(!vData.numero && vaga.numero){ db.ref('vagas/'+id+'/numero').set(vaga.numero); }
          }
      });
      atualizarPainel();
      atualizarListaVagas();
  });

  canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

  // Criação via clique (admin) ou toque com long-press
  scene.onPointerObservable.add(async (pointerInfo)=>{
      if(pointerInfo.type !== BABYLON.PointerEventTypes.POINTERPICK) return;

      const pick = pointerInfo.pickInfo; 
      if(!pick || !pick.hit) return;

      const evt = pointerInfo.event || {};
      const isTouch = evt.pointerType === "touch";

      // ADMIN → Criar vaga com botão direito em qualquer ponto
      if(role==='admin' && (evt.button === 2 || (evt.pointerType === "touch" && evt.longPress))){
          const pos = pick.pickedPoint.clone(); pos.y+=0.01;
          const mesh = criarVagaContorno(pos);
          mesh.rotation.y = 0;
          if(mesh.material) mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
          const ref = db.ref('vagas').push();
          const id = ref.key;
          const numero = `VAGA ${nextVagaNumber++}`;
          const vaga = { mesh, ocupada:false, carro:null, id, carModel:null, numero };
          vagas.push(vaga);
          await ref.set({ x: pos.x, y: pos.y, z: pos.z, rotY:0, ocupada:false, carModel:null, numero });
          // adiciona label
          atualizarNumeroVaga(vaga);
          selecionarVaga(vaga);
          atualizarPainel();
          atualizarListaVagas();
          return;
      }

      // Movimentação ou seleção de vaga
      if(moverAtivo && vagaSelecionada){
          vagaSelecionada.mesh.position=pick.pickedPoint.clone().add(new BABYLON.Vector3(0,0.01,0));
          if(vagaSelecionada.carro) posicionarSobreVaga(vagaSelecionada.carro,vagaSelecionada.mesh);
          if(vagaSelecionada.id) atualizarFirebase(vagaSelecionada,vagaSelecionada.id);
          moverAtivo=false;
      } else {
          const pickedMesh = pick.pickedMesh;
          const vaga = encontrarVagaPorMesh(pickedMesh);
          if(vaga) selecionarVaga(vaga);
      }
  });

  // Toque longo (mobile) para criar vaga
  let touchTimer = null;
  canvas.addEventListener("touchstart", (e) => {
    if(role === "admin"){
      touchTimer = setTimeout(() => {
        const pick = scene.pick(scene.pointerX, scene.pointerY);
        if(pick && pick.hit){
          const pos = pick.pickedPoint.clone(); pos.y += 0.01;
          const mesh = criarVagaContorno(pos);
          mesh.rotation.y = 0;
          if(mesh.material) mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
          const ref = db.ref('vagas').push();
          const id = ref.key;
          const numero = `VAGA ${nextVagaNumber++}`;
          const vaga = { mesh, ocupada:false, carro:null, id, carModel:null, numero };
          vagas.push(vaga);
          ref.set({ x: pos.x, y: pos.y, z: pos.z, rotY:0, ocupada:false, carModel:null, numero });
          atualizarNumeroVaga(vaga);
          selecionarVaga(vaga);
          atualizarPainel();
          atualizarListaVagas();
        }
      }, 800); // 800ms = toque longo
    }
  });

  canvas.addEventListener("touchend", (e) => {
    if(touchTimer){
      clearTimeout(touchTimer);
      touchTimer = null;
    }

    // Seleção de vaga com toque simples
    const pick = scene.pick(scene.pointerX, scene.pointerY);
    if(pick && pick.hit){
      const vaga = encontrarVagaPorMesh(pick.pickedMesh);
      if(vaga) selecionarVaga(vaga);
    }
  });

  // Expor pequenas funções de interface global (se quiser usar nos botões)
  window.ocuparVaga = ocuparVaga;
  window.liberarVaga = liberarVaga;
  window.rotacionarVaga = rotacionarVaga;
  window.ativarMover = ativarMover;
  window.deletarVaga = deletarVaga;
  window.toggleVagaStatus = toggleVagaStatus;
  window.login = login;

  engine.runRenderLoop(()=>scene.render());
  window.addEventListener("resize",()=>{
    engine.resize();
  });
</script>
</body>
</html>
