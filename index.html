<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Gerenciador de Estacionamento 3D</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; display:block; }
    #adminPanel { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); color: white; padding: 10px; border-radius: 8px; font-family: Arial; line-height: 1.4;}
    #loginPanel { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.6); color: white; padding: 10px; border-radius: 8px; font-family: Arial; }
    #vagaPanel { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 8px; font-family: Arial; display: none; }
    #vagaPanel button { margin: 3px; padding: 6px 10px; }
    .hint { font-size: 12px; opacity: 0.85; }

    /* Controles mobile */
    #mobileControls { position: absolute; bottom: 12px; right: 12px; display: none; gap: 8px; z-index: 10; }
    #mobileControls .pad { display: grid; grid-template-columns: 50px 50px 50px; grid-template-rows: 50px 50px 50px; gap: 8px; justify-content: center; align-items: center; }
    #mobileControls .zoom { display: grid; grid-auto-rows: 50px; gap: 8px; margin-left: 8px; }
    #mobileControls button { border: none; border-radius: 12px; background: rgba(0,0,0,0.6); color: #fff; font-size: 18px; box-shadow: 0 4px 14px rgba(0,0,0,0.25); }
    #mobileControls button:active { transform: scale(0.98); }

    @media (max-width: 768px) { /* mostrar apenas em telas menores / mobile */
      #mobileControls { display: flex; }
    }
  </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="adminPanel">
  <div>Vagas livres: <span id="livres">0</span> | Ocupadas: <span id="ocupadas">0</span></div>
  <div class="hint">Admin: clique com <b>botão direito</b> no chão para criar uma vaga</div>
</div>

<div id="loginPanel">
  Perfil:
  <select id="roleSelect">
    <option value="viewer">Usuário</option>
    <option value="operator">Operador</option>
    <option value="admin">Administrador</option>
  </select><br/>
  Senha: <input type="password" id="userPass"/>
  <button onclick="login()">Entrar</button>
</div>

<div id="vagaPanel">
  <h4>Gerenciar Vaga</h4>
  <button onclick="ocuparVaga()">Ocupar</button>
  <button onclick="liberarVaga()">Desocupar</button>
  <button onclick="rotacionarVaga(-10)">⟲ Rotacionar</button>
  <button onclick="rotacionarVaga(10)">Rotacionar ⟳</button>
  <button onclick="ativarMover()">Mover</button>
  <button onclick="deletarVaga()">Deletar</button>
</div>

<!-- Controles Mobile (setas + zoom) -->
<div id="mobileControls">
  <div class="pad">
    <div></div>
    <button id="btnUp">▲</button>
    <div></div>
    <button id="btnLeft">◀</button>
    <button id="btnDown">▼</button>
    <button id="btnRight">▶</button>
    <div></div>
    <div></div>
    <div></div>
  </div>
  <div class="zoom">
    <button id="btnZoomIn">＋</button>
    <button id="btnZoomOut">－</button>
  </div>
</div>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyAE8AgqS_rpQygvmO6ugTX5yQSjQDwJ0vk",
    authDomain: "smamus3d.firebaseapp.com",
    databaseURL: "https://smamus3d-default-rtdb.firebaseio.com",
    projectId: "smamus3d",
    storageBucket: "smamus3d.firebasestorage.app",
    messagingSenderId: "951385126549",
    appId: "1:951385126549:web:c80ed059acdf45bdcc8d9c",
    measurementId: "G-H52V7SLBGE"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);
  let scene, camera;
  let vagas = [];
  let vagaSelecionada = null;
  let moverAtivo = false;
  let role = "viewer";
  const PASSWORDS = { operator: "op123", admin: "admin123" };
  const PARKING_MODEL_FILE = "modelo.glb"; 
  const CAR_BASE_URL = "https://linckrafael.github.io/cars3D/";
  const CAR_MODELS = ["car1.glb","car2.glb","car3.glb","car5.glb","car6.glb","car7.glb","car8.glb","car9.glb","car10.glb","car12.glb","car13.glb","car14.glb","car15.glb","car19.glb"];
  const VAGA_LARGURA = 4.0;
  const VAGA_COMPRIMENTO = 8.0;
  const VAGA_ALTURA = 2.0;
  const MARGEM_ESCALA = 0.95;

  function login(){
    const selected = document.getElementById("roleSelect").value;
    const pass = document.getElementById("userPass").value;
    if(selected === "viewer"){
      role = "viewer";
      alert("Modo Visualizador");
    } else if(pass === PASSWORDS[selected]){
      role = selected;
      alert("Modo " + (role === "admin" ? "Administrador" : "Operador") + " Ativado");
    } else {
      alert("Senha incorreta");
      return;
    }
    atualizarInterface();
  }

  function atualizarInterface(){
    document.querySelectorAll("#vagaPanel button").forEach(btn => btn.style.display = "none");
    if(role === "operator"){
      document.querySelector("button[onclick='ocuparVaga()']").style.display = "inline-block";
      document.querySelector("button[onclick='liberarVaga()']").style.display = "inline-block";
    }
    if(role === "admin"){
      document.querySelectorAll("#vagaPanel button").forEach(btn => btn.style.display = "inline-block");
    }
  }

  function atualizarPainel(){
    const livres = vagas.filter(v => !v.ocupada).length;
    const ocupadas = vagas.length - livres;
    document.getElementById("livres").innerText = livres;
    document.getElementById("ocupadas").innerText = ocupadas;
  }

  scene = new BABYLON.Scene(engine);

  // --- Câmera universal melhorada ---
  camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(68, 80, -15), scene);
  camera.rotation.x = Math.PI / 5; // inclinação
  camera.rotation.y = 10;           // direção no eixo Y
  camera.attachControl(canvas,true);

  // Teclas de movimentação
  camera.keysUp.push(87); camera.keysDown.push(83);
  camera.keysLeft.push(65); camera.keysRight.push(68);
  camera.speed = 15;
  camera.angularSensibility = 450;
  camera.inertia = 0.1;

  // Scroll do mouse
  camera.inputs.addMouseWheel();
  camera.wheelPrecision = 50;

  // Limite da altura da câmera
  const MIN_Y = 1;
  const MAX_Y = 100;
  scene.registerBeforeRender(() => {
    if (camera.position.y < MIN_Y) camera.position.y = MIN_Y;
    if (camera.position.y > MAX_Y) camera.position.y = MAX_Y;
  });

  // Melhor mobilidade no mobile (e botões auxiliares)
  camera.inputs.removeByType("FreeCameraTouchInput");
  camera.inputs.add(new BABYLON.FreeCameraTouchInput());
  camera.angularSensibility = 500;
  camera.touchAngularSensibility = 2000;
  camera.panningSensibility = 50;

  // Helpers de movimento para botões mobile
  const STEP = 5;      // passo de movimento
  const ZOOM_STEP = 8; // passo de zoom
  function moveRelative(forward, right){
    // forward/right relativos à orientação da câmera, travando no plano XZ
    const f = camera.getDirection(new BABYLON.Vector3(0,0,1));
    f.y = 0; f.normalize();
    const r = camera.getDirection(new BABYLON.Vector3(1,0,0));
    r.y = 0; r.normalize();
    const delta = f.scale(forward * STEP).add(r.scale(right * STEP));
    camera.position.addInPlace(delta);
  }
  function zoomRelative(sign){
    const f = camera.getDirection(new BABYLON.Vector3(0,0,1));
    const delta = f.scale(sign * ZOOM_STEP);
    camera.position.addInPlace(delta);
  }
  function attachHold(btn, action){
    if(!btn) return;
    let interval = null;
    const start = (e)=>{ e.preventDefault(); action(); interval = setInterval(action, 100); };
    const end = ()=>{ if(interval){ clearInterval(interval); interval = null; } };
    btn.addEventListener('touchstart', start, {passive:false});
    btn.addEventListener('mousedown', start);
    window.addEventListener('touchend', end);
    window.addEventListener('mouseup', end);
    window.addEventListener('touchcancel', end);
  }
  attachHold(document.getElementById('btnUp'), ()=>moveRelative(1,0));
  attachHold(document.getElementById('btnDown'), ()=>moveRelative(-1,0));
  attachHold(document.getElementById('btnLeft'), ()=>moveRelative(0,-1));
  attachHold(document.getElementById('btnRight'), ()=>moveRelative(0,1));
  attachHold(document.getElementById('btnZoomIn'), ()=>zoomRelative(1));
  attachHold(document.getElementById('btnZoomOut'), ()=>zoomRelative(-1));

  // Cena básica
  new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

  const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 1000, height: 1000}, scene);
  ground.position.y = -0.05;
  ground.isPickable = true;
  const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
  groundMat.diffuseColor = new BABYLON.Color3(0.4,0.4,0.4);
  ground.material = groundMat;

  const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000}, scene);
  skybox.isPickable = false;
  const skyboxMat = new BABYLON.StandardMaterial("skyBoxMat", scene);
  skyboxMat.backFaceCulling = false;
  skyboxMat.diffuseColor = new BABYLON.Color3(0,0,0);
  skyboxMat.specularColor = new BABYLON.Color3(0,0,0);
  skyboxMat.reflectionTexture = new BABYLON.CubeTexture("https://playground.babylonjs.com/textures/skybox", scene);
  skyboxMat.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
  skybox.material = skyboxMat;

  BABYLON.SceneLoader.Append("https://linckrafael.github.io/Smamus3Dv7/", PARKING_MODEL_FILE, scene);

  // --- Utilitários / Vagas / Firebase ---  
  function getSizeOf(node){ const bv = node.getHierarchyBoundingVectors(true); return { size: bv.max.subtract(bv.min), bv }; }
  function criarVagaContorno(pos){ 
      const plane = BABYLON.MeshBuilder.CreatePlane("vagaPlane",{width:VAGA_LARGURA,height:VAGA_COMPRIMENTO},scene); 
      plane.rotation.x=Math.PI/2; 
      plane.position=pos.clone().add(new BABYLON.Vector3(0,0.01,0)); 
      const mat=new BABYLON.StandardMaterial("vagaMat",scene); 
      mat.diffuseColor=new BABYLON.Color3(0,1,0); 
      mat.alpha=0.3; 
      plane.material=mat; 
      plane.isPickable=true; 
      return plane; 
  }

  function selecionarVaga(vaga){ vagaSelecionada=vaga; document.getElementById("vagaPanel").style.display="block"; atualizarInterface(); }
  function encontrarVagaPorMesh(mesh){ return vagas.find(v=>v.mesh===mesh); }
  function normalizarOrientacao(carroRoot){ 
      let {size}=getSizeOf(carroRoot); 
      const minAxis=(size.x<=size.y && size.x<=size.z)?'x':(size.y<=size.x && size.y<=size.z?'y':'z'); 
      if(minAxis==='z'){ carroRoot.rotate(BABYLON.Axis.X,-Math.PI/2); } 
      else if(minAxis==='x'){ carroRoot.rotate(BABYLON.Axis.Z,Math.PI/2); } 
      ({size}=getSizeOf(carroRoot)); 
      if(size.x>size.z){ carroRoot.rotate(BABYLON.Axis.Y,-Math.PI/2); } 
  }
  function posicionarSobreVaga(carroRoot,vagaMesh){ 
      const {bv}=getSizeOf(carroRoot); 
      const minY=bv.min.y; 
      carroRoot.position.x=vagaMesh.position.x; 
      carroRoot.position.z=vagaMesh.position.z; 
      carroRoot.position.y=vagaMesh.position.y-minY+0.01; 
  }
  function escalarParaVaga(carroRoot){ 
      const oldRotY=carroRoot.rotation.y; carroRoot.rotation.y=0; 
      const {size}=getSizeOf(carroRoot); 
      const sx=VAGA_LARGURA/size.x; 
      const sy=VAGA_ALTURA/size.y; 
      const sz=VAGA_COMPRIMENTO/size.z; 
      const s=Math.min(sx,sy,sz)*MARGEM_ESCALA; 
      carroRoot.scaling.set(s,s,s); 
      carroRoot.rotation.y=oldRotY; 
  }

  async function carregarCarroNormalizado(vaga, modelFile){ 
      const file = modelFile || CAR_MODELS[Math.floor(Math.random()*CAR_MODELS.length)]; 
      const container = await BABYLON.SceneLoader.LoadAssetContainerAsync(CAR_BASE_URL, file, scene); 
      const carroRoot = new BABYLON.TransformNode("carroRoot",scene); 
      container.meshes.forEach(m=>{if(m.parent==null)m.parent=carroRoot;}); 
      container.addAllToScene(); 
      carroRoot.rotationQuaternion=null; 
      normalizarOrientacao(carroRoot); 
      escalarParaVaga(carroRoot); 
      carroRoot.rotation.y=vaga.mesh.rotation.y; 
      posicionarSobreVaga(carroRoot,vaga.mesh); 
      return carroRoot; 
  }

  function atualizarFirebase(vaga, id){
      db.ref('vagas/'+id).set({
          x: vaga.mesh.position.x,
          z: vaga.mesh.position.z,
          rotY: vaga.mesh.rotation.y,
          ocupada: vaga.ocupada,
          carModel: vaga.carModel || null
      });
  }

  async function ocuparVagaFirebase(vaga){
      if(!vaga.ocupada) return;
      if(vaga.carro) return; // já carregado
      try{
          if(!vaga.carModel){ // compatibilidade com dados antigos
              vaga.carModel = CAR_MODELS[Math.floor(Math.random()*CAR_MODELS.length)];
              db.ref('vagas/'+vaga.id+'/carModel').set(vaga.carModel);
          }
          const carro = await carregarCarroNormalizado(vaga, vaga.carModel);
          vaga.carro = carro;
      }catch(e){ console.error(e); }
  }

  async function ocuparVaga(){
      if(role==="viewer"||!vagaSelecionada||vagaSelecionada.ocupada)return;
      vagaSelecionada.ocupada=true;
      if(!vagaSelecionada.carModel){
        vagaSelecionada.carModel = CAR_MODELS[Math.floor(Math.random()*CAR_MODELS.length)];
      }
      if(vagaSelecionada.mesh.material)vagaSelecionada.mesh.material.diffuseColor=new BABYLON.Color3(1,0,0);
      if(vagaSelecionada.carro){vagaSelecionada.carro.dispose(); vagaSelecionada.carro=null;}
      try{
          const carro=await carregarCarroNormalizado(vagaSelecionada, vagaSelecionada.carModel);
          vagaSelecionada.carro=carro;
          atualizarFirebase(vagaSelecionada, vagaSelecionada.id);
      }catch(e){
          console.error("Erro ao carregar carro:",e);
          vagaSelecionada.ocupada=false;
          vagaSelecionada.carModel=null;
          if(vagaSelecionada.mesh.material)vagaSelecionada.mesh.material.diffuseColor=new BABYLON.Color3(0,1,0);
      }
      atualizarPainel();
  }

  function liberarVaga(){
      if(role==="viewer"||!vagaSelecionada)return;
      vagaSelecionada.ocupada=false;
      vagaSelecionada.carModel=null;
      if(vagaSelecionada.mesh.material)vagaSelecionada.mesh.material.diffuseColor=new BABYLON.Color3(0,1,0);
      if(vagaSelecionada.carro){vagaSelecionada.carro.dispose(); vagaSelecionada.carro=null;}
      atualizarFirebase(vagaSelecionada, vagaSelecionada.id);
      atualizarPainel();
  }

  function rotacionarVaga(angulo){
      if(role!=="admin"||!vagaSelecionada)return;
      const rad=BABYLON.Tools.ToRadians(angulo);
      vagaSelecionada.mesh.rotation.y+=rad;
      if(vagaSelecionada.carro){
          vagaSelecionada.carro.rotation.y+=rad;
          posicionarSobreVaga(vagaSelecionada.carro,vagaSelecionada.mesh);
      }
      atualizarFirebase(vagaSelecionada, vagaSelecionada.id);
  }

  function ativarMover(){ if(role==="admin"&&vagaSelecionada)moverAtivo=true; }

  function deletarVaga(){
      if(role!=="admin"||!vagaSelecionada)return;
      if(vagaSelecionada.carro){vagaSelecionada.carro.dispose(); vagaSelecionada.carro=null;}
      vagaSelecionada.mesh.dispose();
      db.ref('vagas/'+vagaSelecionada.id).remove();
      vagas=vagas.filter(v=>v!==vagaSelecionada);
      vagaSelecionada=null;
      document.getElementById("vagaPanel").style.display="none";
      atualizarPainel();
  }

  // Sincronização Firebase → Cena
  db.ref('vagas').on('value', snapshot => {
      const data = snapshot.val();
      if(!data) return;
      Object.keys(data).forEach(id => {
          const vData = data[id];
          let vaga = vagas.find(v=>v.id===id);
          if(!vaga){
              const novaMesh = criarVagaContorno(new BABYLON.Vector3(vData.x,0.01,vData.z));
              novaMesh.rotation.y = vData.rotY;
              if(vData.ocupada && novaMesh.material) novaMesh.material.diffuseColor = new BABYLON.Color3(1,0,0);
              else if(novaMesh.material) novaMesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
              vaga = { mesh: novaMesh, ocupada: vData.ocupada, carro: null, id, carModel: vData.carModel || null };
              vagas.push(vaga);
              if(vaga.ocupada) ocuparVagaFirebase(vaga);
          } else {
              vaga.mesh.position.x = vData.x;
              vaga.mesh.position.z = vData.z;
              vaga.mesh.rotation.y = vData.rotY;
              vaga.ocupada = vData.ocupada;
              vaga.carModel = vData.carModel || null;
              if(vaga.ocupada && vaga.mesh.material) vaga.mesh.material.diffuseColor = new BABYLON.Color3(1,0,0);
              else if(vaga.mesh.material) vaga.mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
              if(vaga.ocupada && !vaga.carro) ocuparVagaFirebase(vaga);
              if(!vaga.ocupada && vaga.carro){ vaga.carro.dispose(); vaga.carro=null; }
          }
      });
      atualizarPainel();
  });

  // Impedir menu de contexto e permitir criação com botão direito
  canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

  // Interações de clique
  scene.onPointerObservable.add(async (pointerInfo)=>{
      if(pointerInfo.type!==BABYLON.PointerEventTypes.POINTERPICK)return;
      const pick=pointerInfo.pickInfo; if(!pick.hit)return;
      const evt = pointerInfo.event || {};

      // ADMIN → Criar vaga com botão direito
      if(role==='admin' && evt.button===2){
          const pos = pick.pickedPoint.clone();
          pos.y = 0.01;
          const mesh = criarVagaContorno(pos);
          mesh.rotation.y = 0;
          if(mesh.material) mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
          const ref = db.ref('vagas').push();
          const id = ref.key;
          const vaga = { mesh, ocupada: false, carro: null, id, carModel: null };
          vagas.push(vaga);
          await ref.set({ x: pos.x, z: pos.z, rotY: 0, ocupada: false, carModel: null });
          selecionarVaga(vaga);
          atualizarPainel();
          return; // não processa seleção normal
      }

      // Mover vaga ativa
      if(moverAtivo && vagaSelecionada){
          vagaSelecionada.mesh.position=pick.pickedPoint.clone().add(new BABYLON.Vector3(0,0.01,0));
          if(vagaSelecionada.carro) posicionarSobreVaga(vagaSelecionada.carro,vagaSelecionada.mesh);
          atualizarFirebase(vagaSelecionada,vagaSelecionada.id);
          moverAtivo=false;
      } else {
          // Seleção de vaga
          const pickedMesh = pick.pickedMesh;
          const vaga = encontrarVagaPorMesh(pickedMesh);
          if(vaga) selecionarVaga(vaga);
      }
  });

  engine.runRenderLoop(()=>scene.render());
  window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
