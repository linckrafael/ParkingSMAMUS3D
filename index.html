<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Gerenciador de Estacionamento 3D</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; display:block; }
    #adminPanel {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.6); color: white;
      padding: 10px; border-radius: 8px; font-family: Arial; line-height: 1.4;
    }
    #loginPanel {
      position: absolute; top: 10px; right: 10px;
      background: rgba(0,0,0,0.6); color: white;
      padding: 10px; border-radius: 8px; font-family: Arial;
    }
    #vagaPanel {
      position: absolute; bottom: 10px; left: 10px;
      background: rgba(0,0,0,0.7); color: white;
      padding: 10px; border-radius: 8px; font-family: Arial;
      display: none;
    }
    #vagaPanel button { margin: 3px; padding: 6px 10px; }
    .hint { font-size: 12px; opacity: 0.85; }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div id="adminPanel">
    <div>Vagas livres: <span id="livres">0</span> | Ocupadas: <span id="ocupadas">0</span></div>
    <div class="hint">Dica: <b>Shift + clique</b> cria nova vaga. <b>Delete</b> apaga a vaga selecionada.</div>
  </div>

  <div id="loginPanel">
    Senha Admin: <input type="password" id="adminPass"/>
    <button onclick="loginAdmin()">Entrar</button>
  </div>

  <div id="vagaPanel">
    <h4>Gerenciar Vaga</h4>
    <button onclick="ocuparVaga()">Ocupar</button>
    <button onclick="liberarVaga()">Desocupar</button>
    <button onclick="rotacionarVaga(-15)">⟲ Rotacionar</button>
    <button onclick="rotacionarVaga(15)">Rotacionar ⟳</button>
    <button onclick="ativarMover()">Mover</button>
    <button onclick="deletarVaga()">Deletar</button>
  </div>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    let scene, camera;
    let isAdmin = false;
    let vagas = [];
    let vagaSelecionada = null;
    let moverAtivo = false;

    const ADMIN_PASSWORD = "admin123"; 
    const PARKING_MODEL_FILE = "modelo.glb"; 

    const CAR_BASE_URL = "https://linckrafael.github.io/cars3D/";
    const CAR_MODELS = ["car1.glb","car2.glb","car3.glb","car5.glb","car6.glb","car7.glb","car8.glb","car9.glb","car10.glb","car12.glb","car13.glb","car14.glb","car15.glb","car19.glb"];

    // Dimensões alvo da vaga
    const VAGA_LARGURA = 3.0;      
    const VAGA_COMPRIMENTO = 6.0;  
    const VAGA_ALTURA = 2.0;       
    const MARGEM_ESCALA = 0.95;    

    function loginAdmin(){
      const pass = document.getElementById("adminPass").value;
      if(pass === ADMIN_PASSWORD){
        isAdmin = true;
        alert("Modo Administrador Ativado");
      } else {
        alert("Senha incorreta");
      }
    }

    function atualizarPainel(){
      const livres = vagas.filter(v => !v.ocupada).length;
      const ocupadas = vagas.length - livres;
      document.getElementById("livres").innerText = livres;
      document.getElementById("ocupadas").innerText = ocupadas;
    }

    scene = new BABYLON.Scene(engine);

    // Navegação estilo WASD + scroll
    camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 12, -28), scene);
    camera.attachControl(canvas, true);
    camera.keysUp.push(87);    
    camera.keysDown.push(83);  
    camera.keysLeft.push(65);  
    camera.keysRight.push(68); 
    camera.speed = 15;
    camera.angularSensibility = 450;
    camera.inertia = 0.1;
    camera.inputs.addMouseWheel();
    camera.wheelPrecision = 50;

    camera.rotation.y = Math.PI;

    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

    // Carrega o estacionamento
    BABYLON.SceneLoader.Append("https://linckrafael.github.io/Smamus3Dv7/", PARKING_MODEL_FILE, scene);

    // ---- Util ----
    function getSizeOf(node){
      const bv = node.getHierarchyBoundingVectors(true);
      const size = bv.max.subtract(bv.min);
      return { size, bv };
    }

    function criarVagaContorno(pos){
      const plane = BABYLON.MeshBuilder.CreatePlane("vagaPlane", {width: VAGA_LARGURA, height: VAGA_COMPRIMENTO}, scene);
      plane.rotation.x = Math.PI/2;
      plane.position = pos.clone().add(new BABYLON.Vector3(0,0.01,0));
      const mat = new BABYLON.StandardMaterial("vagaMat", scene);
      mat.diffuseColor = new BABYLON.Color3(0,1,0);
      mat.alpha = 0.3;
      plane.material = mat;
      plane.isPickable = true;
      return plane;
    }

    function selecionarVaga(vaga){
      vagaSelecionada = vaga;
      document.getElementById("vagaPanel").style.display = "block";
    }

    function encontrarVagaPorMesh(mesh){
      return vagas.find(v => v.mesh === mesh);
    }

    // Normaliza orientação
    function normalizarOrientacao(carroRoot){
      let { size } = getSizeOf(carroRoot);
      const minAxis = (size.x <= size.y && size.x <= size.z) ? 'x' : (size.y <= size.x && size.y <= size.z ? 'y' : 'z');

      if(minAxis === 'z'){
        carroRoot.rotate(BABYLON.Axis.X, -Math.PI/2);
      } else if(minAxis === 'x'){
        carroRoot.rotate(BABYLON.Axis.Z, Math.PI/2);
      }

      ({ size } = getSizeOf(carroRoot));
      if(size.x > size.z){
        carroRoot.rotate(BABYLON.Axis.Y, -Math.PI/2);
      }
    }

    // Posiciona apoiando no chão
    function posicionarSobreVaga(carroRoot, vagaMesh){
      const { bv } = getSizeOf(carroRoot);
      const minY = bv.min.y;
      carroRoot.position.x = vagaMesh.position.x;
      carroRoot.position.z = vagaMesh.position.z;
      carroRoot.position.y = vagaMesh.position.y - minY + 0.01;
    }

    // Escala para caber na vaga sem depender da rotação da vaga
    function escalarParaVaga(carroRoot){
      const oldRotY = carroRoot.rotation.y;
      carroRoot.rotation.y = 0;

      const { size } = getSizeOf(carroRoot);
      const sx = VAGA_LARGURA / size.x;
      const sy = VAGA_ALTURA  / size.y;
      const sz = VAGA_COMPRIMENTO / size.z;
      const s = Math.min(sx, sy, sz) * MARGEM_ESCALA;
      carroRoot.scaling.set(s, s, s);

      carroRoot.rotation.y = oldRotY;
    }

    // ============ OCUPAR VAGA ============
    async function carregarCarroNormalizado(vaga){
      const idx = Math.floor(Math.random()*CAR_MODELS.length);
      const file = CAR_MODELS[idx];

      const container = await BABYLON.SceneLoader.LoadAssetContainerAsync(CAR_BASE_URL, file, scene);

      const carroRoot = new BABYLON.TransformNode("carroRoot", scene);
      container.meshes.forEach(m => { if(m.parent == null) m.parent = carroRoot; });
      container.addAllToScene();

      carroRoot.rotationQuaternion = null;

      normalizarOrientacao(carroRoot);
      escalarParaVaga(carroRoot);
      carroRoot.rotation.y = vaga.mesh.rotation.y;
      posicionarSobreVaga(carroRoot, vaga.mesh);

      return carroRoot;
    }

    async function ocuparVaga(){
      if(!isAdmin || !vagaSelecionada || vagaSelecionada.ocupada) return;

      vagaSelecionada.ocupada = true;
      if(vagaSelecionada.mesh.material) vagaSelecionada.mesh.material.diffuseColor = new BABYLON.Color3(1,0,0);

      if(vagaSelecionada.carro){ vagaSelecionada.carro.dispose(); vagaSelecionada.carro = null; }

      try{
        const carro = await carregarCarroNormalizado(vagaSelecionada);
        vagaSelecionada.carro = carro;
      }catch(e){
        console.error("Erro ao carregar carro:", e);
        vagaSelecionada.ocupada = false;
        if(vagaSelecionada.mesh.material) vagaSelecionada.mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
      }

      atualizarPainel();
    }

    function liberarVaga(){
      if(!isAdmin || !vagaSelecionada) return;

      vagaSelecionada.ocupada = false;
      if(vagaSelecionada.mesh.material) vagaSelecionada.mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);

      if(vagaSelecionada.carro){
        vagaSelecionada.carro.dispose();
        vagaSelecionada.carro = null;
      }
      atualizarPainel();
    }

    function rotacionarVaga(angulo){
      if(!isAdmin || !vagaSelecionada) return;
      const rad = BABYLON.Tools.ToRadians(angulo);
      vagaSelecionada.mesh.rotation.y += rad;

      if(vagaSelecionada.carro){
        vagaSelecionada.carro.rotation.y += rad;
        posicionarSobreVaga(vagaSelecionada.carro, vagaSelecionada.mesh);
      }
    }

    function ativarMover(){ if(isAdmin && vagaSelecionada) moverAtivo = true; }

    function deletarVaga(){
      if(!isAdmin || !vagaSelecionada) return;

      if(vagaSelecionada.carro){ vagaSelecionada.carro.dispose(); vagaSelecionada.carro = null; }
      vagaSelecionada.mesh.dispose();

      vagas = vagas.filter(v => v !== vagaSelecionada);
      vagaSelecionada = null;
      document.getElementById("vagaPanel").style.display = "none";
      atualizarPainel();
    }

    // Picking
    scene.onPointerObservable.add(async (pointerInfo) => {
      if(pointerInfo.type !== BABYLON.PointerEventTypes.POINTERPICK) return;
      const pick = pointerInfo.pickInfo;
      if(!pick.hit) return;

      if(moverAtivo && vagaSelecionada){
        vagaSelecionada.mesh.position = pick.pickedPoint.clone().add(new BABYLON.Vector3(0,0.01,0));
        if(vagaSelecionada.carro){
          posicionarSobreVaga(vagaSelecionada.carro, vagaSelecionada.mesh);
        }
        moverAtivo = false;
        return;
      }

      const isShift = pointerInfo.event && pointerInfo.event.shiftKey;
      const vaga = encontrarVagaPorMesh(pick.pickedMesh);

      if(vaga && isAdmin){
        selecionarVaga(vaga);
        return;
      }

      if(isAdmin && isShift){
        const novaMesh = criarVagaContorno(pick.pickedPoint);
        const vagaObj = { mesh: novaMesh, ocupada: false, carro: null };
        vagas.push(vagaObj);
        selecionarVaga(vagaObj);
        atualizarPainel();
      }
    });

    window.addEventListener("keydown", (ev) => {
      if(ev.key === "Delete" || ev.key === "Del"){ deletarVaga(); }
    });

    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
