<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Gerenciador de Estacionamento 3D</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; display:block; touch-action: none; }
    #adminPanel { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); color: white; padding: 10px; border-radius: 8px; font-family: Arial; line-height: 1.4;}
    #loginPanel { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.6); color: white; padding: 10px; border-radius: 8px; font-family: Arial; }
    #vagaPanel { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 8px; font-family: Arial; display: none; pointer-events: auto; }
    #vagaPanel button { margin: 3px; padding: 6px 10px; }
    .hint { font-size: 12px; opacity: 0.85; }

    /* Controles mobile (mantidos, mas o principal agora é gesto de pinça e giro) */
    #mobileControls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 20px;
      z-index: 10;
    }
    #mobileControls .pad {
      display: grid;
      grid-template-columns: 70px 70px 70px;
      grid-template-rows: 70px 70px 70px;
      gap: 12px;
      justify-content: center;
      align-items: center;
    }
    #mobileControls .zoom {
      display: grid;
      grid-auto-rows: 70px;
      gap: 12px;
      margin-left: 12px;
    }
    #mobileControls button {
      border: none;
      border-radius: 20px;
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 28px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.25);
    }
    #mobileControls button:active { transform: scale(0.95); }

    @media (max-width: 1024px) { 
      #mobileControls { display: flex }
    }
  </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="adminPanel">
  <div>Vagas livres: <span id="livres">0</span> | Ocupadas: <span id="ocupadas">0</span></div>
  <div class="hint">Admin: clique com <b>botão direito</b> em qualquer ponto para criar uma vaga</div>
</div>

<div id="loginPanel">
  Perfil:
  <select id="roleSelect">
    <option value="viewer">Usuário</option>
    <option value="operator">Operador</option>
    <option value="admin">Administrador</option>
  </select><br/>
  Senha: <input type="password" id="userPass"/>
  <button onclick="login()">Entrar</button>
</div>

<div id="vagaPanel">
  <h4>Gerenciar Vaga</h4>
  <button onclick="ocuparVaga()">Ocupar</button>
  <button onclick="liberarVaga()">Desocupar</button>
  <button onclick="rotacionarVaga(-10)">⟲ Rotacionar</button>
  <button onclick="rotacionarVaga(10)">Rotacionar ⟳</button>
  <button onclick="ativarMover()">Mover</button>
  <button onclick="deletarVaga()">Deletar</button>
</div>

<!-- Controles Mobile (opcionais) -->
<div id="mobileControls">
  <div class="pad">
    <div></div>
    <button id="btnUp">▲</button>
    <div></div>
    <button id="btnLeft">◀</button>
    <button id="btnDown">▼</button>
    <button id="btnRight">▶</button>
    <div></div>
    <div></div>
    <div></div>
  </div>
  <div class="zoom">
    <button id="btnZoomIn">＋</button>
    <button id="btnZoomOut">－</button>
  </div>
</div>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyAE8AgqS_rpQygvmO6ugTX5yQSjQDwJ0vk",
    authDomain: "smamus3d.firebaseapp.com",
    databaseURL: "https://smamus3d-default-rtdb.firebaseio.com",
    projectId: "smamus3d",
    storageBucket: "smamus3d.firebasestorage.app",
    messagingSenderId: "951385126549",
    appId: "1:951385126549:web:c80ed059acdf45bdcc8d9c",
    measurementId: "G-H52V7SLBGE"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);
  let scene, camera;
  let vagas = [];
  let vagaSelecionada = null;
  let moverAtivo = false;
  let role = "viewer";
  const PASSWORDS = { operator: "op123", admin: "admin123" };
  const PARKING_MODEL_FILE = "modelo.glb"; 
  const CAR_BASE_URL = "https://linckrafael.github.io/cars3D/";
  const CAR_MODELS = ["car1.glb","car2.glb","car3.glb","car5.glb","car6.glb","car7.glb","car8.glb","car9.glb","car10.glb","car12.glb","car13.glb","car14.glb","car15.glb","car19.glb"];
  const VAGA_LARGURA = 4.0;
  const VAGA_COMPRIMENTO = 8.0;
  const VAGA_ALTURA = 2.0;
  const MARGEM_ESCALA = 0.95;

  function login(){
    const selected = document.getElementById("roleSelect").value;
    const pass = document.getElementById("userPass").value;
    if(selected === "viewer"){
      role = "viewer";
      alert("Modo Visualizador");
    } else if(pass === PASSWORDS[selected]){
      role = selected;
      alert("Modo " + (role === "admin" ? "Administrador" : "Operador") + " Ativado");
    } else {
      alert("Senha incorreta");
      return;
    }
    atualizarInterface();
  }

  function atualizarInterface(){
    document.querySelectorAll("#vagaPanel button").forEach(btn => btn.style.display = "none");
    if(role === "operator"){
      document.querySelector("button[onclick='ocuparVaga()']").style.display = "inline-block";
      document.querySelector("button[onclick='liberarVaga()']").style.display = "inline-block";
    }
    if(role === "admin"){
      document.querySelectorAll("#vagaPanel button").forEach(btn => btn.style.display = "inline-block");
    }
  }

  function atualizarPainel(){
    const livres = vagas.filter(v => !v.ocupada).length;
    const ocupadas = vagas.length - livres;
    document.getElementById("livres").innerText = livres;
    document.getElementById("ocupadas").innerText = ocupadas;
  }

  scene = new BABYLON.Scene(engine);

  // =====================
  // CÂMERAS: Desktop x Mobile
  // =====================
  const isMobile = () => ("ontouchstart" in window) || navigator.maxTouchPoints > 0 || window.innerWidth <= 1024;

  function createDesktopCamera(){
    const cam = new BABYLON.UniversalCamera("desktopCam", new BABYLON.Vector3(68, 80, -15), scene);
    cam.rotation.x = Math.PI / 5;
    cam.rotation.y = 10;
    cam.attachControl(canvas, true);
    cam.keysUp.push(87); cam.keysDown.push(83);
    cam.keysLeft.push(65); cam.keysRight.push(68);
    cam.speed = 15;
    cam.angularSensibility = 450;
    cam.inertia = 0.1;
    cam.inputs.addMouseWheel();
    cam.wheelPrecision = 50;
    const MIN_Y = 1, MAX_Y = 100;
    scene.registerBeforeRender(()=>{
      if(cam.position.y<MIN_Y) cam.position.y=MIN_Y;
      if(cam.position.y>MAX_Y) cam.position.y=MAX_Y;
    });
    return cam;
  }

  function createMobileCamera(){
    // ArcRotate com gestos nativos: pinça = zoom, arrastar = girar, dois dedos = pan
    const target = new BABYLON.Vector3(68, 0, -15);
    const alpha = Math.PI * 1.2;
    const beta  = Math.PI / 3; // inclinação olhando para baixo
    const radius = 120;
    const cam = new BABYLON.ArcRotateCamera("mobileCam", alpha, beta, radius, target, scene);
    cam.attachControl(canvas, true);

    // Gestos
    cam.useNaturalPinchZoom = true;          // zoom mais intuitivo
    cam.pinchDeltaPercentage = 0.01;         // sensibilidade do pinch
    cam.panningSensibility = 50;             // dois dedos = pan
    cam.angularSensibilityTouch = 2000;      // suaviza giro no toque

    // Limites para não atravessar/virar demais
    cam.lowerRadiusLimit = 20;
    cam.upperRadiusLimit = 200;
    cam.lowerBetaLimit   = 0.15;             // não ficar totalmente de lado
    cam.upperBetaLimit   = Math.PI/2.05;     // não passar do horizonte

    // Pequeno amortecimento
    cam.inertia = 0.85;
    cam.zoomToMouseLocation = false; // no mobile, segue o centro

    return cam;
  }

  camera = isMobile() ? createMobileCamera() : createDesktopCamera();

  // Utilitários de movimento/zoom (funcionam para ambas as câmeras)
  const STEP = 5;
  const ZOOM_STEP = 8;
  function isArc() { return camera && camera.getClassName && camera.getClassName() === "ArcRotateCamera"; }

  function moveRelative(forward, right){
      const f = camera.getDirection(new BABYLON.Vector3(0,0,1)); f.y=0; f.normalize();
      const r = camera.getDirection(new BABYLON.Vector3(1,0,0)); r.y=0; r.normalize();
      const delta = f.scale(forward*STEP).add(r.scale(right*STEP));
      if(isArc()){
        camera.target.addInPlace(delta);
      } else {
        camera.position.addInPlace(delta);
      }
  }
  function zoomRelative(sign){
      if(isArc()){
        const next = camera.radius - sign*ZOOM_STEP;
        camera.radius = BABYLON.Scalar.Clamp(next, camera.lowerRadiusLimit||5, camera.upperRadiusLimit||300);
      } else {
        const f = camera.getDirection(new BABYLON.Vector3(0,0,1));
        camera.position.addInPlace(f.scale(sign*ZOOM_STEP));
      }
  }

  function attachHold(btn, action){
      if(!btn) return;
      let interval=null;
      const start=(e)=>{ e.preventDefault(); action(); interval=setInterval(action,100); };
      const end=()=>{ if(interval){ clearInterval(interval); interval=null; } };
      btn.addEventListener('touchstart',start,{passive:false});
      btn.addEventListener('mousedown',start);
      window.addEventListener('touchend',end);
      window.addEventListener('mouseup',end);
      window.addEventListener('touchcancel',end);
  }
  attachHold(document.getElementById('btnUp'), ()=>moveRelative(1,0));
  attachHold(document.getElementById('btnDown'), ()=>moveRelative(-1,0));
  attachHold(document.getElementById('btnLeft'), ()=>moveRelative(0,-1));
  attachHold(document.getElementById('btnRight'), ()=>moveRelative(0,1));
  attachHold(document.getElementById('btnZoomIn'), ()=>zoomRelative(1));
  attachHold(document.getElementById('btnZoomOut'), ()=>zoomRelative(-1));

  // Luz, chão e skybox
  new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
  const ground = BABYLON.MeshBuilder.CreateGround("ground",{width:1000,height:1000},scene);
  ground.position.y=-0.05;
  ground.isPickable=true;
  const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
  groundMat.diffuseColor = new BABYLON.Color3(0.4,0.4,0.4);
  ground.material=groundMat;

  const skybox=BABYLON.MeshBuilder.CreateBox("skyBox",{size:1000},scene);
  skybox.isPickable=false;
  const skyboxMat=new BABYLON.StandardMaterial("skyBoxMat",scene);
  skyboxMat.backFaceCulling=false;
  skyboxMat.diffuseColor=new BABYLON.Color3(0,0,0);
  skyboxMat.specularColor=new BABYLON.Color3(0,0,0);
  skyboxMat.reflectionTexture=new BABYLON.CubeTexture("https://playground.babylonjs.com/textures/skybox",scene);
  skyboxMat.reflectionTexture.coordinatesMode=BABYLON.Texture.SKYBOX_MODE;
  skybox.material=skyboxMat;

  BABYLON.SceneLoader.Append("https://linckrafael.github.io/Smamus3Dv7/", PARKING_MODEL_FILE, scene);

  // --- Funções utilitárias (vagas, carros, firebase) ---
  function getSizeOf(node){ const bv=node.getHierarchyBoundingVectors(true); return { size: bv.max.subtract(bv.min), bv }; }
  function criarVagaContorno(pos){ 
      const plane = BABYLON.MeshBuilder.CreatePlane("vagaPlane",{width:VAGA_LARGURA,height:VAGA_COMPRIMENTO},scene); 
      plane.rotation.x=Math.PI/2; plane.position=pos.clone().add(new BABYLON.Vector3(0,0.01,0)); 
      const mat=new BABYLON.StandardMaterial("vagaMat",scene); mat.diffuseColor=new BABYLON.Color3(0,1,0); mat.alpha=0.3; plane.material=mat; plane.isPickable=true; 
      return plane; 
  }
  function selecionarVaga(vaga){ vagaSelecionada=vaga; document.getElementById("vagaPanel").style.display="block"; atualizarInterface(); }
  function encontrarVagaPorMesh(mesh){ return vagas.find(v=>v.mesh===mesh); }
  function normalizarOrientacao(carroRoot){ 
      let {size}=getSizeOf(carroRoot); 
      const minAxis=(size.x<=size.y && size.x<=size.z)?'x':(size.y<=size.x && size.y<=size.z?'y':'z'); 
      if(minAxis==='z'){ carroRoot.rotate(BABYLON.Axis.X,-Math.PI/2); } 
      else if(minAxis==='x'){ carroRoot.rotate(BABYLON.Axis.Z,Math.PI/2); } 
      ({size}=getSizeOf(carroRoot)); 
      if(size.x>size.z){ carroRoot.rotate(BABYLON.Axis.Y,-Math.PI/2); } 
  }
  function posicionarSobreVaga(carroRoot,vagaMesh){ 
      const {bv}=getSizeOf(carroRoot); 
      const minY=bv.min.y; 
      carroRoot.position.x=vagaMesh.position.x; 
      carroRoot.position.z=vagaMesh.position.z; 
      carroRoot.position.y=vagaMesh.position.y-minY+0.01; 
  }
  function escalarParaVaga(carroRoot){ 
      const oldRotY=carroRoot.rotation.y; carroRoot.rotation.y=0; 
      const {size}=getSizeOf(carroRoot); 
      const sx=VAGA_LARGURA/size.x; 
      const sy=VAGA_ALTURA/size.y; 
      const sz=VAGA_COMPRIMENTO/size.z; 
      const s=Math.min(sx,sy,sz)*MARGEM_ESCALA; 
      carroRoot.scaling.set(s,s,s); 
      carroRoot.rotation.y=oldRotY; 
  }

  async function carregarCarroNormalizado(vaga, modelFile){ 
      const file = modelFile || CAR_MODELS[Math.floor(Math.random()*CAR_MODELS.length)]; 
      const container = await BABYLON.SceneLoader.LoadAssetContainerAsync(CAR_BASE_URL, file, scene); 
      const carroRoot = new BABYLON.TransformNode("carroRoot",scene); 
      container.meshes.forEach(m=>{if(m.parent==null)m.parent=carroRoot;}); 
      container.addAllToScene(); 
      carroRoot.rotationQuaternion=null; 
      normalizarOrientacao(carroRoot); 
      escalarParaVaga(carroRoot); 
      carroRoot.rotation.y=vaga.mesh.rotation.y; 
      posicionarSobreVaga(carroRoot,vaga.mesh); 
      return carroRoot; 
  }

  function atualizarFirebase(vaga, id){
      db.ref('vagas/'+id).set({
          x: vaga.mesh.position.x,
          y: vaga.mesh.position.y,
          z: vaga.mesh.position.z,
          rotY: vaga.mesh.rotation.y,
          ocupada: vaga.ocupada,
          carModel: vaga.carModel || null
      });
  }

  async function ocuparVagaFirebase(vaga){
      if(!vaga.ocupada) return;
      if(vaga.carro) return; 
      try{
          if(!vaga.carModel){
              vaga.carModel = CAR_MODELS[Math.floor(Math.random()*CAR_MODELS.length)];
              db.ref('vagas/'+vaga.id+'/carModel').set(vaga.carModel);
          }
          const carro = await carregarCarroNormalizado(vaga, vaga.carModel);
          vaga.carro = carro;
      }catch(e){ console.error(e); }
  }

  async function ocuparVaga(){
      if(role==="viewer"||!vagaSelecionada||vagaSelecionada.ocupada)return;
      vagaSelecionada.ocupada=true;
      if(!vagaSelecionada.carModel){
        vagaSelecionada.carModel = CAR_MODELS[Math.floor(Math.random()*CAR_MODELS.length)];
      }
      if(vagaSelecionada.mesh.material)vagaSelecionada.mesh.material.diffuseColor=new BABYLON.Color3(1,0,0);
      if(vagaSelecionada.carro){vagaSelecionada.carro.dispose(); vagaSelecionada.carro=null;}
      try{
          const carro=await carregarCarroNormalizado(vagaSelecionada, vagaSelecionada.carModel);
          vagaSelecionada.carro=carro;
          atualizarFirebase(vagaSelecionada, vagaSelecionada.id);
      }catch(e){
          console.error("Erro ao carregar carro:",e);
          vagaSelecionada.ocupada=false;
          vagaSelecionada.carModel=null;
          if(vagaSelecionada.mesh.material)vagaSelecionada.mesh.material.diffuseColor=new BABYLON.Color3(0,1,0);
      }
      atualizarPainel();
  }

  function liberarVaga(){
      if(role==="viewer"||!vagaSelecionada)return;
      vagaSelecionada.ocupada=false;
      vagaSelecionada.carModel=null;
      if(vagaSelecionada.mesh.material)vagaSelecionada.mesh.material.diffuseColor=new BABYLON.Color3(0,1,0);
      if(vagaSelecionada.carro){vagaSelecionada.carro.dispose(); vagaSelecionada.carro=null;}
      atualizarFirebase(vagaSelecionada, vagaSelecionada.id);
      atualizarPainel();
  }

  function rotacionarVaga(angulo){
      if(role!=="admin"||!vagaSelecionada)return;
      const rad=BABYLON.Tools.ToRadians(angulo);
      vagaSelecionada.mesh.rotation.y+=rad;
      if(vagaSelecionada.carro){
          vagaSelecionada.carro.rotation.y+=rad;
          posicionarSobreVaga(vagaSelecionada.carro,vagaSelecionada.mesh);
      }
      atualizarFirebase(vagaSelecionada, vagaSelecionada.id);
  }

  function ativarMover(){ if(role==="admin"&&vagaSelecionada)moverAtivo=true; }

  function deletarVaga(){
      if(role!=="admin"||!vagaSelecionada)return;
      if(vagaSelecionada.carro){vagaSelecionada.carro.dispose(); vagaSelecionada.carro=null;}
      vagaSelecionada.mesh.dispose();
      db.ref('vagas/'+vagaSelecionada.id).remove();
      vagas=vagas.filter(v=>v!==vagaSelecionada);
      vagaSelecionada=null;
      document.getElementById("vagaPanel").style.display="none";
      atualizarPainel();
  }

  db.ref('vagas').on('value', snapshot => {
      const data = snapshot.val();
      if(!data) return;
      Object.keys(data).forEach(id => {
          const vData = data[id];
          let vaga = vagas.find(v=>v.id===id);
          if(!vaga){
              const novaMesh = criarVagaContorno(new BABYLON.Vector3(vData.x,vData.y,vData.z));
              novaMesh.rotation.y = vData.rotY;
              if(vData.ocupada && novaMesh.material) novaMesh.material.diffuseColor = new BABYLON.Color3(1,0,0);
              else if(novaMesh.material) novaMesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
              vaga = { mesh: novaMesh, ocupada: vData.ocupada, carro: null, id, carModel: vData.carModel || null };
              vagas.push(vaga);
              if(vaga.ocupada) ocuparVagaFirebase(vaga);
          } else {
              vaga.mesh.position.x = vData.x;
              vaga.mesh.position.y = vData.y;
              vaga.mesh.position.z = vData.z;
              vaga.mesh.rotation.y = vData.rotY;
              vaga.ocupada = vData.ocupada;
              vaga.carModel = vData.carModel || null;
              if(vaga.ocupada && vaga.mesh.material) vaga.mesh.material.diffuseColor = new BABYLON.Color3(1,0,0);
              else if(vaga.mesh.material) vaga.mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
              if(vaga.ocupada && !vaga.carro) ocuparVagaFirebase(vaga);
              if(!vaga.ocupada && vaga.carro){ vaga.carro.dispose(); vaga.carro=null; }
          }
      });
      atualizarPainel();
  });

  canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

  scene.onPointerObservable.add(async (pointerInfo)=>{
      if(pointerInfo.type !== BABYLON.PointerEventTypes.POINTERPICK) return;

      const pick = pointerInfo.pickInfo; 
      if(!pick || !pick.hit) return;

      const evt = pointerInfo.event || {};
      const isTouch = evt.pointerType === "touch";

      // ADMIN → Criar vaga com botão direito em qualquer ponto (ou toque longo abaixo)
      if(role==='admin' && (evt.button === 2 || (evt.pointerType === "touch" && evt.longPress))){
          const pos = pick.pickedPoint.clone(); pos.y+=0.01;
          const mesh = criarVagaContorno(pos);
          mesh.rotation.y = 0;
          if(mesh.material) mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
          const ref = db.ref('vagas').push();
          const id = ref.key;
          const vaga = { mesh, ocupada:false, carro:null, id, carModel:null };
          vagas.push(vaga);
          await ref.set({ x: pos.x, y: pos.y, z: pos.z, rotY:0, ocupada:false, carModel:null });
          selecionarVaga(vaga);
          atualizarPainel();
          return;
      }

      // Movimentação ou seleção de vaga
      if(moverAtivo && vagaSelecionada){
          vagaSelecionada.mesh.position=pick.pickedPoint.clone().add(new BABYLON.Vector3(0,0.01,0));
          if(vagaSelecionada.carro) posicionarSobreVaga(vagaSelecionada.carro,vagaSelecionada.mesh);
          atualizarFirebase(vagaSelecionada,vagaSelecionada.id);
          moverAtivo=false;
      } else {
          const pickedMesh = pick.pickedMesh;
          const vaga = encontrarVagaPorMesh(pickedMesh);
          if(vaga) selecionarVaga(vaga);
      }
  });

  // Toque longo (mobile) para criar vaga
  let touchTimer = null;
  canvas.addEventListener("touchstart", (e) => {
    if(role === "admin"){
      touchTimer = setTimeout(() => {
        const pick = scene.pick(scene.pointerX, scene.pointerY);
        if(pick && pick.hit){
          const pos = pick.pickedPoint.clone(); pos.y += 0.01;
          const mesh = criarVagaContorno(pos);
          mesh.rotation.y = 0;
          if(mesh.material) mesh.material.diffuseColor = new BABYLON.Color3(0,1,0);
          const ref = db.ref('vagas').push();
          const id = ref.key;
          const vaga = { mesh, ocupada:false, carro:null, id, carModel:null };
          vagas.push(vaga);
          ref.set({ x: pos.x, y: pos.y, z: pos.z, rotY:0, ocupada:false, carModel:null });
          selecionarVaga(vaga);
          atualizarPainel();
        }
      }, 800); // 800ms = toque longo
    }
  });

  canvas.addEventListener("touchend", (e) => {
    if(touchTimer){
      clearTimeout(touchTimer);
      touchTimer = null;
    }

    // Seleção de vaga com toque simples
    const pick = scene.pick(scene.pointerX, scene.pointerY);
    if(pick && pick.hit){
      const vaga = encontrarVagaPorMesh(pick.pickedMesh);
      if(vaga) selecionarVaga(vaga);
    }
  });

  engine.runRenderLoop(()=>scene.render());
  window.addEventListener("resize",()=>{
    engine.resize();
    // Se quiser alternar a câmera automaticamente ao redimensionar (opcional):
    // const shouldBeMobile = isMobile();
    // const isCurrentlyArc = camera && camera.getClassName && camera.getClassName()==='ArcRotateCamera';
    // if(shouldBeMobile && !isCurrentlyArc){ camera.detachControl(); camera = createMobileCamera(); }
    // if(!shouldBeMobile && isCurrentlyArc){ camera.detachControl(); camera = createDesktopCamera(); }
  });
</script>
</body>
</html>
